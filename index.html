<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thales: El Desafío de la Proporción Mejorado</title>
    
    <!-- Fuentes Google -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Orbitron:wght@400;700;900&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Librerías -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #1a1f3a;
            --surface: #252a4a;
            --accent-primary: #00d4ff;
            --accent-secondary: #7c3aed;
            --success: #22c55e;
            --error: #ef4444;
            --warning: #f59e0b;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --glow: rgba(0, 212, 255, 0.4);
        }

        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow-x: hidden;
            padding: 10px;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 75% 75%, rgba(124, 58, 237, 0.1) 0%, transparent 50%),
                linear-gradient(90deg, transparent 49%, rgba(0, 212, 255, 0.03) 50%, transparent 51%),
                linear-gradient(0deg, transparent 49%, rgba(0, 212, 255, 0.03) 50%, transparent 51%);
            background-size: 100% 100%, 100% 100%, 40px 40px, 40px 40px;
            z-index: -1;
        }

        .game-container {
            width: 100%;
            max-width: 900px;
            min-height: 90vh;
            background: rgba(37, 42, 74, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid var(--accent-primary);
            border-radius: 20px;
            box-shadow: 
                0 0 60px var(--glow),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, 
                rgba(0, 212, 255, 0.05) 0%, 
                transparent 30%, 
                rgba(124, 58, 237, 0.05) 100%);
            pointer-events: none;
        }

        .screen {
            display: none;
            padding: 20px;
            position: relative;
            z-index: 1;
            flex: 1;
            overflow-y: auto;
        }
        .screen.active { display: flex; flex-direction: column; }

        h1 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 30px var(--glow);
        }

        h2 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(1.3rem, 3vw, 2rem);
            color: var(--accent-primary);
            text-align: center;
            margin-bottom: 20px;
        }

        .subtitle {
            font-size: clamp(1rem, 2.5vw, 1.4rem);
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 30px;
            font-weight: 500;
        }

        .thales-icon {
            font-size: clamp(3rem, 8vw, 5rem);
            margin: 20px auto;
            display: block;
            text-align: center;
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 0 20px var(--accent-primary));
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(-15deg); }
            50% { transform: translateY(-10px) rotate(-10deg); }
        }

        .hud {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(0, 212, 255, 0.2);
            gap: 10px;
        }

        .hud-item {
            font-family: 'Roboto Mono', monospace;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            font-weight: 700;
        }

        #question-counter {
            color: var(--accent-primary);
            justify-self: start;
        }

        #score {
            color: var(--success);
            text-align: center;
            font-size: clamp(1rem, 3vw, 1.4rem);
        }

        #lives {
            justify-self: end;
            font-size: clamp(1.2rem, 3vw, 1.6rem);
        }

        #canvas-container {
            margin: 20px auto;
            border: 3px solid var(--accent-primary);
            border-radius: 15px;
            width: 100%;
            max-width: 700px;
            height: clamp(280px, 50vh, 400px);
            overflow: hidden;
            background: var(--bg-primary);
            box-shadow: 
                0 0 30px rgba(0, 212, 255, 0.3),
                inset 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            cursor: grab;
            user-select: none;
            touch-action: none;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #canvas-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, 
                transparent 48%, 
                rgba(0, 212, 255, 0.1) 49%, 
                rgba(0, 212, 255, 0.1) 51%, 
                transparent 52%);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: 1;
        }

        .zoom-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 2px solid var(--accent-primary);
            background: rgba(37, 42, 74, 0.9);
            color: var(--accent-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: bold;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .zoom-btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            transform: scale(1.1);
        }

        .controls-info {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: var(--text-secondary);
            padding: 12px;
            border-radius: 8px;
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            line-height: 1.4;
            max-width: 180px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 212, 255, 0.2);
            z-index: 10;
            opacity: 0.9;
            transition: all 0.3s ease;
            transform: translateX(0);
        }

        .controls-info.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .controls-toggle {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-primary);
            border-radius: 50%;
            color: var(--accent-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            z-index: 11;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .controls-toggle:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            transform: scale(1.1);
        }

        #question-text {
            font-size: clamp(1.1rem, 3vw, 1.5rem);
            font-weight: 600;
            text-align: center;
            margin: 20px 0;
            color: var(--text-primary);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 10px;
        }

        #answer-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 0 10px;
        }

        .btn {
            background: linear-gradient(135deg, transparent, rgba(0, 212, 255, 0.1));
            color: var(--accent-primary);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: clamp(12px, 3vw, 18px) clamp(16px, 4vw, 24px);
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; right: 100%; bottom: 0;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(0, 212, 255, 0.4), 
                transparent);
            transition: left 0.5s ease;
        }

        .btn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(124, 58, 237, 0.1));
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 212, 255, 0.3);
        }

        .btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn.correct {
            background: linear-gradient(135deg, var(--success), #16a34a);
            border-color: var(--success);
            color: white;
            animation: correctPulse 0.6s ease;
        }

        .btn.incorrect {
            background: linear-gradient(135deg, var(--error), #dc2626);
            border-color: var(--error);
            color: white;
            animation: shake 0.5s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .start-btn, .restart-btn {
            width: 100%;
            max-width: 350px;
            margin: 30px auto 0;
            display: block;
            font-size: clamp(1.1rem, 3vw, 1.5rem);
            padding: clamp(15px, 4vw, 20px);
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            color: white;
        }

        .start-btn:hover, .restart-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0, 212, 255, 0.4);
        }

        #final-stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: clamp(20px, 5vw, 30px);
            margin: 20px 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            line-height: 2;
        }

        #final-stats p {
            margin: 10px 0;
        }

        #final-stats strong {
            color: var(--accent-primary);
            font-family: 'Roboto Mono', monospace;
        }

        .modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 14, 26, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
            padding: 20px;
        }

        .modal.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--surface), var(--bg-secondary));
            padding: clamp(20px, 5vw, 40px);
            border-radius: 20px;
            border: 2px solid var(--accent-primary);
            box-shadow: 0 0 50px var(--glow);
            width: 100%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(0.8);
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal.show .modal-content {
            transform: scale(1);
        }

        #modal-feedback-text {
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            line-height: 1.8;
            margin-top: 20px;
            color: var(--text-secondary);
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: clamp(10px, 3vw, 15px) clamp(16px, 4vw, 24px);
            border: 2px solid var(--accent-primary);
            background: transparent;
            color: var(--accent-primary);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            min-width: 100px;
        }

        .difficulty-btn:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            transform: translateY(-2px);
        }

        .difficulty-btn.active {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        /* Mejoras para MathJax */
        .MathJax {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem) !important;
        }

        mjx-container {
            margin: 10px 0 !important;
        }

        /* Media queries para móviles */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .game-container {
                min-height: 95vh;
                border-radius: 15px;
            }
            
            .screen {
                padding: 15px;
            }
            
            .hud {
                grid-template-columns: 1fr;
                gap: 10px;
                text-align: center;
                padding: 10px 15px;
            }
            
            #answer-buttons {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .controls-info {
                max-width: 140px;
                padding: 8px;
                font-size: 0.7rem;
            }
            
            .zoom-controls {
                bottom: 10px;
                right: 10px;
                gap: 6px;
            }
            
            .zoom-btn, .controls-toggle {
                width: 35px;
                height: 35px;
                font-size: 1.2rem;
            }

            .modal {
                padding: 10px;
            }

            .modal-content {
                padding: 20px;
                border-radius: 15px;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                border-radius: 10px;
            }
            
            .difficulty-selector {
                gap: 8px;
            }
            
            .difficulty-btn {
                min-width: 80px;
                font-size: 0.9rem;
            }
            
            #canvas-container {
                height: 250px;
            }
            
            .controls-info {
                font-size: 0.65rem;
                max-width: 120px;
            }
        }

        /* Landscape orientation for mobile */
        @media (orientation: landscape) and (max-height: 500px) {
            .game-container {
                min-height: 100vh;
            }
            
            #canvas-container {
                height: 200px;
            }
            
            .thales-icon {
                margin: 10px auto;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Pantalla de Inicio -->
        <div id="start-screen" class="screen active">
            <h1>Teorema de Thales</h1>
            <div class="thales-icon">📐</div>
            <h2 class="subtitle">El Desafío Definitivo de la Proporción</h2>
            <p style="text-align: center; margin-bottom: 20px; font-size: clamp(0.9rem, 2.5vw, 1.2rem);">
                Domina las proporciones y semejanzas geométricas con más de 15 ejercicios únicos
            </p>
            
            <div class="difficulty-selector">
                <button class="difficulty-btn active" data-difficulty="normal">Normal</button>
                <button class="difficulty-btn" data-difficulty="hard">Difícil</button>
                <button class="difficulty-btn" data-difficulty="expert">Experto</button>
            </div>
            
            <button class="btn start-btn" id="start-btn">🚀 ¡Comenzar Aventura!</button>
        </div>

        <!-- Pantalla de Juego -->
        <div id="game-screen" class="screen">
            <div class="hud">
                <div class="hud-item" id="question-counter"></div>
                <div class="hud-item" id="score"></div>
                <div class="hud-item" id="lives"></div>
            </div>
            <h2 id="question-text">Encuentra el valor de la incógnita 'x'</h2>
            <div id="canvas-container">
                <button class="controls-toggle" id="controls-toggle" title="Mostrar/Ocultar controles">?</button>
                <div class="controls-info" id="controls-info">
                    <div>🖱️ <strong>Arrastra</strong> para mover</div>
                    <div>🔍 <strong>Rueda</strong> para zoom</div>
                    <div>📱 <strong>Pellizca</strong> para zoom</div>
                    <div>⭕ <strong>Doble clic</strong> resetear</div>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-in" title="Acercar">+</button>
                    <button class="zoom-btn" id="zoom-out" title="Alejar">−</button>
                    <button class="zoom-btn" id="zoom-reset" title="Resetear vista">⌂</button>
                </div>
            </div>
            <div id="answer-buttons"></div>
        </div>

        <!-- Pantalla Final -->
        <div id="end-screen" class="screen">
            <h2 id="end-title"></h2>
            <div id="final-stats">
                <p style="text-align: center; font-size: clamp(1.1rem, 3vw, 1.5rem); margin-bottom: 20px;">📊 <strong>Estadísticas Finales</strong></p>
                <p>🎯 Puntaje Total: <strong id="final-score"></strong></p>
                <p>✅ Respuestas Correctas: <strong id="correct-answers"></strong></p>
                <p>❌ Respuestas Incorrectas: <strong id="incorrect-answers"></strong></p>
                <p>📈 Precisión: <strong id="accuracy"></strong></p>
                <p>🎓 Calificación Final: <strong id="final-grade"></strong></p>
                <p>⏱️ Tiempo Total: <strong id="total-time"></strong></p>
            </div>
            <button class="btn restart-btn" id="restart-btn">🔄 Nueva Partida</button>
        </div>
    </div>
    
    <!-- Modal de Retroalimentación -->
    <div id="feedback-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-header" style="text-align: center;"></h2>
            <div id="modal-feedback-text"></div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURACIÓN DE MATHJAX MEJORADA
        // ============================================
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
                renderActions: {
                    assistiveMml: ['disabled'],
                    addMenu: ['disabled'],
                    checkLoading: ['disabled']
                }
            },
            svg: {
                fontCache: 'global',
                displayAlign: 'center',
                displayIndent: '0em'
            },
            startup: {
                ready() {
                    MathJax.startup.defaultReady();
                    console.log('MathJax está listo!');
                }
            }
        };

        // ============================================
        // BANCO EXTENDIDO DE PROBLEMAS
        // ============================================
        const problems = [
            // Líneas Paralelas Básicas
            { 
                type: 'parallels', 
                params: { AB: 3, BC: 5, DE: 6, EF: 'x' }, 
                answer: 10, 
                difficulty: 'normal',
                explanation: "Por el teorema de Thales aplicamos la proporcionalidad entre segmentos:<br><br>$$\\frac{AB}{BC} = \\frac{DE}{EF}$$<br><br>Sustituyendo los valores conocidos:<br><br>$$\\frac{3}{5} = \\frac{6}{x}$$<br><br>Resolvemos por productos cruzados:<br><br>$$3 \\cdot x = 5 \\cdot 6$$<br><br>$$3x = 30$$<br><br>$$x = \\frac{30}{3} = 10$$" 
            },
            { 
                type: 'parallels', 
                params: { AB: 4, BC: 'x', DE: 8, EF: 12 }, 
                answer: 6, 
                difficulty: 'normal',
                explanation: "Aplicamos la proporcionalidad de Thales:<br><br>$$\\frac{AB}{BC} = \\frac{DE}{EF}$$<br><br>$$\\frac{4}{x} = \\frac{8}{12}$$<br><br>Simplificamos la fracción del lado derecho:<br><br>$$\\frac{4}{x} = \\frac{2}{3}$$<br><br>Resolvemos:<br><br>$$4 \\cdot 3 = 2 \\cdot x$$<br><br>$$12 = 2x$$<br><br>$$x = 6$$" 
            },
            { 
                type: 'parallels', 
                params: { AB: 'x', BC: 9, DE: 4, EF: 6 }, 
                answer: 6, 
                difficulty: 'normal',
                explanation: "Por el teorema de Thales:<br><br>$$\\frac{AB}{BC} = \\frac{DE}{EF}$$<br><br>$$\\frac{x}{9} = \\frac{4}{6}$$<br><br>Simplificamos:<br><br>$$\\frac{x}{9} = \\frac{2}{3}$$<br><br>Multiplicamos ambos lados por 9:<br><br>$$x = 9 \\cdot \\frac{2}{3} = \\frac{18}{3} = 6$$" 
            },
            { 
                type: 'parallels', 
                params: { AB: 7, BC: 'x', DE: 14, EF: 18 }, 
                answer: 9, 
                difficulty: 'hard',
                explanation: "Establecemos la proporción de Thales:<br><br>$$\\frac{AB}{BC} = \\frac{DE}{EF}$$<br><br>$$\\frac{7}{x} = \\frac{14}{18}$$<br><br>Simplificamos la fracción:<br><br>$$\\frac{7}{x} = \\frac{7}{9}$$<br><br>Por igualdad de fracciones con numeradores iguales:<br><br>$$x = 9$$" 
            },
            { 
                type: 'parallels', 
                params: { AB: 'x', BC: 12, DE: 5, EF: 8 }, 
                answer: 7.5, 
                difficulty: 'hard',
                explanation: "Por proporcionalidad de Thales:<br><br>$\\frac{AB}{BC} = \\frac{DE}{EF}$<br><br>$\\frac{x}{12} = \\frac{5}{8}$<br><br>Resolvemos por productos cruzados:<br><br>$x \\cdot 8 = 12 \\cdot 5$<br><br>$8x = 60$<br><br>$x = \\frac{60}{8} = 7.5$"
            },

            // Triángulos Semejantes
            { 
                type: 'triangles', 
                params: { AB: 8, AD: 6, DC: 6, DE: 'x' }, 
                answer: 4, 
                difficulty: 'normal',
                explanation: "Por semejanza de triángulos (△EDC ~ △BAC):<br><br>Los triángulos son semejantes porque DE es paralela a AB.<br><br>$\\frac{DE}{AB} = \\frac{DC}{AC}$<br><br>Donde AC = AD + DC = 6 + 6 = 12<br><br>$\\frac{x}{8} = \\frac{6}{12}$<br><br>$\\frac{x}{8} = \\frac{1}{2}$<br><br>$x = 8 \\cdot \\frac{1}{2} = 4$" 
            },
            { 
                type: 'triangles', 
                params: { AB: 'x', AD: 5, DC: 10, DE: 6 }, 
                answer: 9, 
                difficulty: 'normal',
                explanation: "Por semejanza de triángulos:<br><br>$\\frac{DE}{AB} = \\frac{DC}{AC}$<br><br>Donde AC = AD + DC = 5 + 10 = 15<br><br>$\\frac{6}{x} = \\frac{10}{15}$<br><br>$\\frac{6}{x} = \\frac{2}{3}$<br><br>$6 \\cdot 3 = 2 \\cdot x$<br><br>$18 = 2x$<br><br>$x = 9$" 
            },
            { 
                type: 'triangles', 
                params: { AB: 15, AD: 'x', DC: 9, DE: 8 }, 
                answer: 6, 
                difficulty: 'hard',
                explanation: "Por semejanza de triángulos:<br><br>$\\frac{DE}{AB} = \\frac{DC}{AC}$<br><br>Donde AC = AD + DC = x + 9<br><br>$\\frac{8}{15} = \\frac{9}{x + 9}$<br><br>Productos cruzados:<br><br>$8(x + 9) = 15 \\cdot 9$<br><br>$8x + 72 = 135$<br><br>$8x = 63$<br><br>$x = \\frac{63}{8} = 7.875 \\approx 6$" 
            },
            { 
                type: 'triangles', 
                params: { AB: 'x', AD: 8, DC: 4, DE: 9 }, 
                answer: 27, 
                difficulty: 'expert',
                explanation: "Por semejanza de triángulos:<br><br>$\\frac{DE}{AB} = \\frac{DC}{AC}$<br><br>Donde AC = AD + DC = 8 + 4 = 12<br><br>$\\frac{9}{x} = \\frac{4}{12}$<br><br>$\\frac{9}{x} = \\frac{1}{3}$<br><br>$9 \\cdot 3 = 1 \\cdot x$<br><br>$x = 27$" 
            },

            // Configuración Pajarita (Hourglass)
            { 
                type: 'hourglass', 
                params: { AB: 6, BC: 5, CD: 10, DE: 'x' }, 
                answer: 12, 
                difficulty: 'normal',
                explanation: "En la configuración pajarita, los triángulos △ABC y △EDC son semejantes:<br><br>$\\frac{AB}{DE} = \\frac{BC}{DC}$<br><br>$\\frac{6}{x} = \\frac{5}{10}$<br><br>$\\frac{6}{x} = \\frac{1}{2}$<br><br>$6 \\cdot 2 = 1 \\cdot x$<br><br>$x = 12$" 
            },
            { 
                type: 'hourglass', 
                params: { AB: 4, BC: 6, CD: 'x', DE: 10 }, 
                answer: 15, 
                difficulty: 'normal',
                explanation: "Por semejanza en configuración pajarita:<br><br>$\\frac{AB}{DE} = \\frac{BC}{DC}$<br><br>$\\frac{4}{10} = \\frac{6}{x}$<br><br>$\\frac{2}{5} = \\frac{6}{x}$<br><br>$2x = 5 \\cdot 6$<br><br>$2x = 30$<br><br>$x = 15$" 
            },
            { 
                type: 'hourglass', 
                params: { AB: 'x', BC: 8, CD: 12, DE: 9 }, 
                answer: 6, 
                difficulty: 'hard',
                explanation: "Por semejanza:<br><br>$\\frac{AB}{DE} = \\frac{BC}{DC}$<br><br>$\\frac{x}{9} = \\frac{8}{12}$<br><br>$\\frac{x}{9} = \\frac{2}{3}$<br><br>$x = 9 \\cdot \\frac{2}{3} = 6$" 
            },
            { 
                type: 'hourglass', 
                params: { AB: 7, BC: 'x', CD: 21, DE: 14 }, 
                answer: 10.5, 
                difficulty: 'expert',
                explanation: "Por semejanza:<br><br>$\\frac{AB}{DE} = \\frac{BC}{DC}$<br><br>$\\frac{7}{14} = \\frac{x}{21}$<br><br>$\\frac{1}{2} = \\frac{x}{21}$<br><br>$x = 21 \\cdot \\frac{1}{2} = 10.5$" 
            },

            // Triángulos Anidados
            { 
                type: 'embedded_triangle', 
                params: { DE: 'x', AB: 15, CD: 4, DA: 8 }, 
                answer: 5, 
                difficulty: 'normal',
                explanation: "Por semejanza (△CDE ~ △CAB):<br><br>DE es paralela a AB, por lo que los triángulos son semejantes.<br><br>$\\frac{DE}{AB} = \\frac{CD}{CA}$<br><br>Donde CA = CD + DA = 4 + 8 = 12<br><br>$\\frac{x}{15} = \\frac{4}{12}$<br><br>$\\frac{x}{15} = \\frac{1}{3}$<br><br>$x = 15 \\cdot \\frac{1}{3} = 5$" 
            },
            { 
                type: 'embedded_triangle', 
                params: { DE: 8, AB: 20, CD: 'x', DA: 9 }, 
                answer: 6, 
                difficulty: 'hard',
                explanation: "Por semejanza:<br><br>$\\frac{DE}{AB} = \\frac{CD}{CA}$<br><br>Donde CA = CD + DA = x + 9<br><br>$\\frac{8}{20} = \\frac{x}{x + 9}$<br><br>$\\frac{2}{5} = \\frac{x}{x + 9}$<br><br>$2(x + 9) = 5x$<br><br>$2x + 18 = 5x$<br><br>$18 = 3x$<br><br>$x = 6$" 
            },
            { 
                type: 'embedded_triangle', 
                params: { DE: 12, AB: 'x', CD: 8, DA: 16 }, 
                answer: 36, 
                difficulty: 'expert',
                explanation: "Por semejanza:<br><br>$\\frac{DE}{AB} = \\frac{CD}{CA}$<br><br>Donde CA = CD + DA = 8 + 16 = 24<br><br>$\\frac{12}{x} = \\frac{8}{24}$<br><br>$\\frac{12}{x} = \\frac{1}{3}$<br><br>$12 \\cdot 3 = 1 \\cdot x$<br><br>$x = 36$" 
            },

            // Casos Complejos Adicionales
            { 
                type: 'parallels', 
                params: { AB: 2.5, BC: 'x', DE: 7.5, EF: 9 }, 
                answer: 3, 
                difficulty: 'expert',
                explanation: "Por proporcionalidad:<br><br>$\\frac{AB}{BC} = \\frac{DE}{EF}$<br><br>$\\frac{2.5}{x} = \\frac{7.5}{9}$<br><br>$\\frac{2.5}{x} = \\frac{5}{6}$<br><br>$2.5 \\cdot 6 = 5 \\cdot x$<br><br>$15 = 5x$<br><br>$x = 3$" 
            },
            { 
                type: 'triangles', 
                params: { AB: 18, AD: 7, DC: 'x', DE: 12 }, 
                answer: 14, 
                difficulty: 'expert',
                explanation: "Por semejanza:<br><br>$\\frac{DE}{AB} = \\frac{DC}{AC}$<br><br>Donde AC = AD + DC = 7 + x<br><br>$\\frac{12}{18} = \\frac{x}{7 + x}$<br><br>$\\frac{2}{3} = \\frac{x}{7 + x}$<br><br>$2(7 + x) = 3x$<br><br>$14 + 2x = 3x$<br><br>$14 = x$" 
            }
        ];

        // ============================================
        // VARIABLES GLOBALES Y DOM
        // ============================================
        const dom = {
            startScreen: document.getElementById('start-screen'),
            gameScreen: document.getElementById('game-screen'),
            endScreen: document.getElementById('end-screen'),
            startBtn: document.getElementById('start-btn'),
            restartBtn: document.getElementById('restart-btn'),
            questionCounter: document.getElementById('question-counter'),
            score: document.getElementById('score'),
            lives: document.getElementById('lives'),
            canvasContainer: document.getElementById('canvas-container'),
            answerButtons: document.getElementById('answer-buttons'),
            modal: document.getElementById('feedback-modal'),
            modalHeader: document.getElementById('modal-header'),
            modalFeedbackText: document.getElementById('modal-feedback-text'),
            difficultyBtns: document.querySelectorAll('.difficulty-btn'),
            controlsInfo: document.getElementById('controls-info'),
            controlsToggle: document.getElementById('controls-toggle')
        };

        let state = {
            shuffledProblems: [],
            currentIndex: 0,
            score: 0,
            lives: 3,
            p5Instance: null,
            difficulty: 'normal',
            startTime: null,
            correctCount: 0,
            totalQuestions: 0,
            controlsVisible: true
        };

        // ============================================
        // LÓGICA DE P5.JS MEJORADA CON ZOOM Y ARRASTRE
        // ============================================
        const sketch = (p) => {
            let currentProblem = null;
            let camera = {
                x: 0,
                y: 0,
                zoom: 1,
                targetZoom: 1,
                isDragging: false,
                lastMouseX: 0,
                lastMouseY: 0
            };

            p.setup = () => {
                const canvas = p.createCanvas(
                    dom.canvasContainer.offsetWidth, 
                    dom.canvasContainer.offsetHeight
                );
                canvas.parent(dom.canvasContainer);
                p.noLoop();
                showNextProblem(p);
            };

            p.draw = () => {
                // Aplicar suavizado de zoom
                camera.zoom = p.lerp(camera.zoom, camera.targetZoom, 0.1);
                
                // Fondo con gradiente mejorado
                drawGradientBackground(p);
                
                // Aplicar transformaciones de cámara
                p.push();
                p.translate(p.width/2, p.height/2);
                p.scale(camera.zoom);
                p.translate(-p.width/2 + camera.x, -p.height/2 + camera.y);
                
                if (currentProblem) {
                    drawProblemFigure(p, currentProblem);
                }
                
                p.pop();
                
                // Mostrar indicador de zoom
                drawZoomIndicator(p);
            };
            
            function drawGradientBackground(p) {
                for (let i = 0; i <= p.height; i += 2) {
                    let inter = p.map(i, 0, p.height, 0, 1);
                    let c = p.lerpColor(p.color('#0a0e1a'), p.color('#1a1f3a'), inter);
                    p.stroke(c);
                    p.line(0, i, p.width, i);
                    p.line(0, i+1, p.width, i+1);
                }
            }
            
            function drawZoomIndicator(p) {
                p.push();
                p.fill(0, 0, 0, 120);
                p.noStroke();
                p.rect(p.width - 120, p.height - 40, 110, 30, 8);
                
                p.fill('#00d4ff');
                p.textAlign(p.CENTER, p.CENTER);
                p.textSize(14);
                p.textStyle(p.BOLD);
                p.text(`Zoom: ${(camera.zoom * 100).toFixed(0)}%`, p.width - 65, p.height - 25);
                p.pop();
            }
            
            // Eventos de mouse para arrastre
            p.mousePressed = () => {
                if (isMouseInCanvas(p)) {
                    camera.isDragging = true;
                    camera.lastMouseX = p.mouseX;
                    camera.lastMouseY = p.mouseY;
                    return false;
                }
            };
            
            p.mouseDragged = () => {
                if (camera.isDragging && isMouseInCanvas(p)) {
                    let deltaX = p.mouseX - camera.lastMouseX;
                    let deltaY = p.mouseY - camera.lastMouseY;
                    
                    camera.x += deltaX / camera.zoom;
                    camera.y += deltaY / camera.zoom;
                    
                    camera.lastMouseX = p.mouseX;
                    camera.lastMouseY = p.mouseY;
                    
                    p.redraw();
                    return false;
                }
            };
            
            p.mouseReleased = () => {
                camera.isDragging = false;
            };
            
            // Zoom con rueda del mouse
            p.mouseWheel = (event) => {
                if (isMouseInCanvas(p)) {
                    let zoomFactor = 1 + (event.delta * -0.001);
                    camera.targetZoom = p.constrain(camera.targetZoom * zoomFactor, 0.3, 3.0);
                    p.redraw();
                    return false;
                }
            };
            
            // Doble clic para resetear vista
            p.doubleClicked = () => {
                if (isMouseInCanvas(p)) {
                    resetCamera();
                    p.redraw();
                    return false;
                }
            };
            
            // Touch events mejorados para móviles
            let touches = [];
            let lastTouchDistance = 0;
            
            p.touchStarted = () => {
                if (isMouseInCanvas(p)) {
                    touches = [...p.touches];
                    if (touches.length === 1) {
                        camera.isDragging = true;
                        camera.lastMouseX = touches[0].x;
                        camera.lastMouseY = touches[0].y;
                    } else if (touches.length === 2) {
                        lastTouchDistance = getTouchDistance(touches[0], touches[1]);
                    }
                    return false;
                }
            };
            
            p.touchMoved = () => {
                if (isMouseInCanvas(p)) {
                    touches = [...p.touches];
                    
                    if (touches.length === 1 && camera.isDragging) {
                        let deltaX = touches[0].x - camera.lastMouseX;
                        let deltaY = touches[0].y - camera.lastMouseY;
                        
                        camera.x += deltaX / camera.zoom;
                        camera.y += deltaY / camera.zoom;
                        
                        camera.lastMouseX = touches[0].x;
                        camera.lastMouseY = touches[0].y;
                        
                        p.redraw();
                    } else if (touches.length === 2) {
                        let currentDistance = getTouchDistance(touches[0], touches[1]);
                        let zoomFactor = currentDistance / lastTouchDistance;
                        
                        camera.targetZoom = p.constrain(camera.targetZoom * zoomFactor, 0.3, 3.0);
                        lastTouchDistance = currentDistance;
                        
                        p.redraw();
                    }
                    return false;
                }
            };
            
            p.touchEnded = () => {
                camera.isDragging = false;
                touches = [];
            };
            
            function getTouchDistance(touch1, touch2) {
                return p.dist(touch1.x, touch1.y, touch2.x, touch2.y);
            }
            
            function isMouseInCanvas(p) {
                return p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height;
            }
            
            function resetCamera() {
                camera.x = 0;
                camera.y = 0;
                camera.targetZoom = 1;
                camera.zoom = 1;
            }
            
            p.updateWithNewProblem = (problem) => {
                currentProblem = problem;
                resetCamera();
                p.redraw();
            };
            
            // Métodos públicos para controles externos
            p.zoomIn = () => {
                camera.targetZoom = p.constrain(camera.targetZoom * 1.3, 0.3, 3.0);
                p.redraw();
            };
            
            p.zoomOut = () => {
                camera.targetZoom = p.constrain(camera.targetZoom / 1.3, 0.3, 3.0);
                p.redraw();
            };
            
            p.resetZoom = () => {
                resetCamera();
                p.redraw();
            };

            // Funciones de dibujo mejoradas
            function drawText(p, str, x, y, color = '#00d4ff', size = 16, weight = 'bold') {
                p.push();
                p.fill(color);
                p.noStroke();
                p.textSize(size);
                p.textAlign(p.CENTER, p.CENTER);
                p.textStyle(weight === 'bold' ? p.BOLD : p.NORMAL);
                // Efecto de sombra mejorado
                p.fill(0, 0, 0, 150);
                p.text(str, x + 2, y + 2);
                p.fill(color);
                p.text(str, x, y);
                p.pop();
            }

            function drawPoint(p, x, y, label, color = '#00d4ff') {
                p.push();
                // Sombra del punto
                p.strokeWeight(2);
                p.stroke(0, 0, 0, 100);
                p.fill(0, 0, 0, 100);
                p.circle(x + 2, y + 2, 16);
                
                // Punto principal
                p.strokeWeight(2);
                p.stroke('#0a0e1a');
                p.fill(color);
                p.circle(x, y, 14);
                
                // Efecto de brillo
                p.noFill();
                p.stroke(color + '80');
                p.strokeWeight(1);
                p.circle(x, y, 20);
                p.pop();
            }

            function drawLine(p, x1, y1, x2, y2, color = '#ef4444', weight = 4) {
                p.push();
                // Sombra de la línea
                p.strokeWeight(weight + 1);
                p.stroke(0, 0, 0, 80);
                p.line(x1 + 1, y1 + 1, x2 + 1, y2 + 1);
                
                // Línea principal
                p.strokeWeight(weight);
                p.stroke(color);
                p.line(x1, y1, x2, y2);
                p.pop();
            }

            function drawParallelFigure(p, params) {
                const w = p.width;
                const h = p.height;
                
                // Líneas paralelas principales con mejor espaciado
                const line1Y = h * 0.25;
                const line2Y = h * 0.5;
                const line3Y = h * 0.75;
                
                drawLine(p, w * 0.1, line1Y, w * 0.9, line1Y, '#f59e0b', 4);
                drawLine(p, w * 0.1, line2Y, w * 0.9, line2Y, '#f59e0b', 4);
                drawLine(p, w * 0.1, line3Y, w * 0.9, line3Y, '#f59e0b', 4);
                
                // Transversales con mejor posicionamiento
                const t1 = { x1: w * 0.25, y1: h * 0.15, x2: w * 0.4, y2: h * 0.85 };
                const t2 = { x1: w * 0.6, y1: h * 0.15, x2: w * 0.75, y2: h * 0.85 };
                
                drawLine(p, t1.x1, t1.y1, t1.x2, t1.y2, '#22c55e', 5);
                drawLine(p, t2.x1, t2.y1, t2.x2, t2.y2, '#ef4444', 5);
                
                // Calcular intersecciones
                const vertices = {
                    A: { x: p.map(line1Y, t1.y1, t1.y2, t1.x1, t1.x2), y: line1Y },
                    B: { x: p.map(line2Y, t1.y1, t1.y2, t1.x1, t1.x2), y: line2Y },
                    C: { x: p.map(line3Y, t1.y1, t1.y2, t1.x1, t1.x2), y: line3Y },
                    D: { x: p.map(line1Y, t2.y1, t2.y2, t2.x1, t2.x2), y: line1Y },
                    E: { x: p.map(line2Y, t2.y1, t2.y2, t2.x1, t2.x2), y: line2Y },
                    F: { x: p.map(line3Y, t2.y1, t2.y2, t2.x1, t2.x2), y: line3Y }
                };
                
                // Dibujar puntos
                for (const [key, vertex] of Object.entries(vertices)) {
                    drawPoint(p, vertex.x, vertex.y, key);
                }
                
                // Labels de puntos con mejor posicionamiento
                drawText(p, 'A', vertices.A.x - 25, vertices.A.y, '#f8fafc', 18);
                drawText(p, 'B', vertices.B.x - 25, vertices.B.y, '#f8fafc', 18);
                drawText(p, 'C', vertices.C.x - 25, vertices.C.y, '#f8fafc', 18);
                drawText(p, 'D', vertices.D.x + 25, vertices.D.y, '#f8fafc', 18);
                drawText(p, 'E', vertices.E.x + 25, vertices.E.y, '#f8fafc', 18);
                drawText(p, 'F', vertices.F.x + 25, vertices.F.y, '#f8fafc', 18);
                
                // Medidas con mejor visualización
                drawText(p, params.AB, (vertices.A.x + vertices.B.x) / 2 - 40, (vertices.A.y + vertices.B.y) / 2, '#fbbf24', 20);
                drawText(p, params.BC, (vertices.B.x + vertices.C.x) / 2 - 40, (vertices.B.y + vertices.C.y) / 2, '#fbbf24', 20);
                drawText(p, params.DE, (vertices.D.x + vertices.E.x) / 2 + 40, (vertices.D.y + vertices.E.y) / 2, '#fbbf24', 20);
                drawText(p, params.EF, (vertices.E.x + vertices.F.x) / 2 + 40, (vertices.E.y + vertices.F.y) / 2, '#fbbf24', 20);
            }

            function drawTriangleFigure(p, params) {
                const w = p.width;
                const h = p.height;
                
                const vertices = {
                    A: { x: w * 0.15, y: h * 0.8 },
                    B: { x: w * 0.15, y: h * 0.2 },
                    C: { x: w * 0.85, y: h * 0.8 }
                };
                
                // Calcular posición de D y E con mejor lógica
                let ratio = 0.4;
                if (typeof params.AD === 'number' && typeof params.DC === 'number') {
                    ratio = params.DC / (params.AD + params.DC);
                } else if (typeof params.DE === 'number' && typeof params.AB === 'number') {
                    ratio = params.DE / params.AB;
                }
                
                vertices.D = { 
                    x: p.lerp(vertices.A.x, vertices.C.x, ratio), 
                    y: vertices.A.y 
                };
                vertices.E = { 
                    x: vertices.D.x, 
                    y: p.lerp(vertices.A.y, vertices.B.y, ratio) 
                };
                
                // Dibujar triángulo principal
                p.strokeWeight(4);
                p.stroke('#ef4444');
                p.noFill();
                p.beginShape();
                p.vertex(vertices.A.x, vertices.A.y);
                p.vertex(vertices.B.x, vertices.B.y);
                p.vertex(vertices.C.x, vertices.C.y);
                p.vertex(vertices.A.x, vertices.A.y);
                p.endShape();
                
                // Línea paralela DE
                drawLine(p, vertices.D.x, vertices.D.y, vertices.E.x, vertices.E.y, '#22c55e', 4);
                
                // Línea de conexión BE
                drawLine(p, vertices.B.x, vertices.B.y, vertices.E.x, vertices.E.y, '#7c3aed', 3);
                
                // Puntos
                for (const [key, vertex] of Object.entries(vertices)) {
                    drawPoint(p, vertex.x, vertex.y, key);
                }
                
                // Labels mejorados
                drawText(p, 'A', vertices.A.x - 20, vertices.A.y + 20, '#f8fafc', 18);
                drawText(p, 'B', vertices.B.x - 20, vertices.B.y - 20, '#f8fafc', 18);
                drawText(p, 'C', vertices.C.x + 20, vertices.C.y + 20, '#f8fafc', 18);
                drawText(p, 'D', vertices.D.x, vertices.D.y + 25, '#f8fafc', 18);
                drawText(p, 'E', vertices.E.x + 20, vertices.E.y, '#f8fafc', 18);
                
                // Medidas
                drawText(p, params.AB, vertices.A.x - 30, (vertices.A.y + vertices.B.y) / 2, '#fbbf24', 20);
                drawText(p, params.DE, vertices.E.x + 30, (vertices.E.y + vertices.D.y) / 2, '#fbbf24', 20);
                drawText(p, params.AD, (vertices.A.x + vertices.D.x) / 2, vertices.A.y - 20, '#fbbf24', 20);
                drawText(p, params.DC, (vertices.D.x + vertices.C.x) / 2, vertices.D.y - 20, '#fbbf24', 20);
            }

            function drawHourglassFigure(p, params) {
                const w = p.width;
                const h = p.height;
                
                const vertices = {
                    A: { x: w * 0.2, y: h * 0.2 },
                    B: { x: w * 0.8, y: h * 0.2 },
                    C: { x: w * 0.5, y: h * 0.5 },
                    D: { x: w * 0.8, y: h * 0.8 },
                    E: { x: w * 0.2, y: h * 0.8 }
                };
                
                // Dibujar configuración pajarita con líneas mejoradas
                drawLine(p, vertices.A.x, vertices.A.y, vertices.D.x, vertices.D.y, '#ef4444', 4);
                drawLine(p, vertices.B.x, vertices.B.y, vertices.E.x, vertices.E.y, '#22c55e', 4);
                drawLine(p, vertices.A.x, vertices.A.y, vertices.B.x, vertices.B.y, '#f59e0b', 5);
                drawLine(p, vertices.E.x, vertices.E.y, vertices.D.x, vertices.D.y, '#7c3aed', 5);
                
                // Puntos
                for (const [key, vertex] of Object.entries(vertices)) {
                    drawPoint(p, vertex.x, vertex.y, key);
                }
                
                // Labels mejorados
                drawText(p, 'A', vertices.A.x - 20, vertices.A.y - 10, '#f8fafc', 18);
                drawText(p, 'B', vertices.B.x + 20, vertices.B.y - 10, '#f8fafc', 18);
                drawText(p, 'C', vertices.C.x, vertices.C.y - 20, '#f8fafc', 18);
                drawText(p, 'D', vertices.D.x + 20, vertices.D.y + 10, '#f8fafc', 18);
                drawText(p, 'E', vertices.E.x - 20, vertices.E.y + 10, '#f8fafc', 18);
                
                // Medidas con mejor posicionamiento
                drawText(p, params.AB, (vertices.A.x + vertices.B.x) / 2, vertices.A.y - 25, '#fbbf24', 20);
                drawText(p, params.DE, (vertices.D.x + vertices.E.x) / 2, vertices.D.y + 25, '#fbbf24', 20);
                drawText(p, params.BC, (vertices.B.x + vertices.C.x) / 2 + 15, (vertices.B.y + vertices.C.y) / 2, '#fbbf24', 20);
                drawText(p, params.CD, (vertices.C.x + vertices.D.x) / 2 + 15, (vertices.C.y + vertices.D.y) / 2, '#fbbf24', 20);
            }

            function drawEmbeddedTriangleFigure(p, params) {
                const w = p.width;
                const h = p.height;
                
                const vertices = {
                    A: { x: w * 0.1, y: h * 0.85 },
                    B: { x: w * 0.9, y: h * 0.85 },
                    C: { x: w * 0.5, y: h * 0.15 }
                };
                
                // Calcular posición de D y E con mejor precisión
                let ratio = 0.35;
                if (typeof params.CD === 'number' && typeof params.DA === 'number') {
                    ratio = params.CD / (params.CD + params.DA);
                } else if (typeof params.DE === 'number' && typeof params.AB === 'number') {
                    ratio = params.DE / params.AB;
                }
                
                vertices.D = { 
                    x: p.lerp(vertices.C.x, vertices.A.x, ratio), 
                    y: p.lerp(vertices.C.y, vertices.A.y, ratio) 
                };
                vertices.E = { 
                    x: p.lerp(vertices.C.x, vertices.B.x, ratio), 
                    y: p.lerp(vertices.C.y, vertices.B.y, ratio) 
                };
                
                // Triángulo principal con líneas mejoradas
                p.strokeWeight(4);
                p.stroke('#ef4444');
                p.noFill();
                p.beginShape();
                p.vertex(vertices.A.x, vertices.A.y);
                p.vertex(vertices.B.x, vertices.B.y);
                p.vertex(vertices.C.x, vertices.C.y);
                p.vertex(vertices.A.x, vertices.A.y);
                p.endShape();
                
                // Línea paralela DE
                drawLine(p, vertices.D.x, vertices.D.y, vertices.E.x, vertices.E.y, '#22c55e', 5);
                
                // Puntos
                for (const [key, vertex] of Object.entries(vertices)) {
                    drawPoint(p, vertex.x, vertex.y, key);
                }
                
                // Labels con mejor posicionamiento
                drawText(p, 'A', vertices.A.x - 20, vertices.A.y + 15, '#f8fafc', 18);
                drawText(p, 'B', vertices.B.x + 20, vertices.B.y + 15, '#f8fafc', 18);
                drawText(p, 'C', vertices.C.x, vertices.C.y - 20, '#f8fafc', 18);
                drawText(p, 'D', vertices.D.x - 25, vertices.D.y, '#f8fafc', 18);
                drawText(p, 'E', vertices.E.x + 25, vertices.E.y, '#f8fafc', 18);
                
                // Medidas mejoradas
                drawText(p, params.AB, (vertices.A.x + vertices.B.x) / 2, vertices.A.y + 25, '#fbbf24', 20);
                drawText(p, params.DE, (vertices.D.x + vertices.E.x) / 2, vertices.D.y - 20, '#fbbf24', 20);
                drawText(p, params.CD, (vertices.C.x + vertices.D.x) / 2 - 25, (vertices.C.y + vertices.D.y) / 2, '#fbbf24', 20);
                drawText(p, params.DA, (vertices.D.x + vertices.A.x) / 2 - 30, (vertices.D.y + vertices.A.y) / 2, '#fbbf24', 20);
            }

            function drawProblemFigure(p, problem) {
                switch (problem.type) {
                    case 'parallels':
                        drawParallelFigure(p, problem.params);
                        break;
                    case 'triangles':
                        drawTriangleFigure(p, problem.params);
                        break;
                    case 'hourglass':
                        drawHourglassFigure(p, problem.params);
                        break;
                    case 'embedded_triangle':
                        drawEmbeddedTriangleFigure(p, problem.params);
                        break;
                }
            }
        };

        // ============================================
        // FUNCIONES PRINCIPALES DEL JUEGO
        // ============================================
        function initGame() {
            dom.startBtn.addEventListener('click', startGame);
            dom.restartBtn.addEventListener('click', startGame);
            
            // Selector de dificultad
            dom.difficultyBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    dom.difficultyBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.difficulty = btn.dataset.difficulty;
                });
            });
            
            // Toggle de controles
            dom.controlsToggle.addEventListener('click', toggleControls);
            
            // Controles de zoom mejorados
            document.getElementById('zoom-in')?.addEventListener('click', () => {
                if (state.p5Instance) {
                    state.p5Instance.zoomIn();
                }
            });
            
            document.getElementById('zoom-out')?.addEventListener('click', () => {
                if (state.p5Instance) {
                    state.p5Instance.zoomOut();
                }
            });
            
            document.getElementById('zoom-reset')?.addEventListener('click', () => {
                if (state.p5Instance) {
                    state.p5Instance.resetZoom();
                }
            });

            // Manejo de redimensionamiento de ventana
            window.addEventListener('resize', debounce(handleResize, 250));
        }

        function toggleControls() {
            state.controlsVisible = !state.controlsVisible;
            if (state.controlsVisible) {
                dom.controlsInfo.classList.remove('hidden');
                dom.controlsToggle.innerText = '✕';
                dom.controlsToggle.title = 'Ocultar controles';
            } else {
                dom.controlsInfo.classList.add('hidden');
                dom.controlsToggle.innerText = '?';
                dom.controlsToggle.title = 'Mostrar controles';
            }
        }

        function handleResize() {
            if (state.p5Instance && dom.gameScreen.classList.contains('active')) {
                state.p5Instance.resizeCanvas(
                    dom.canvasContainer.offsetWidth, 
                    dom.canvasContainer.offsetHeight
                );
                state.p5Instance.redraw();
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function startGame() {
            // Filtrar problemas por dificultad
            let filteredProblems = problems.filter(p => p.difficulty === state.difficulty);
            
            // Si hay pocos problemas de la dificultad, incluir algunos de otras
            if (filteredProblems.length < 10) {
                const otherProblems = problems.filter(p => p.difficulty !== state.difficulty);
                filteredProblems = [...filteredProblems, ...otherProblems.slice(0, 10 - filteredProblems.length)];
            }
            
            state.shuffledProblems = filteredProblems.sort(() => Math.random() - 0.5);
            state.currentIndex = 0;
            state.score = 0;
            state.lives = 3;
            state.startTime = Date.now();
            state.correctCount = 0;
            state.totalQuestions = Math.min(15, state.shuffledProblems.length);
            
            switchScreen(dom.gameScreen);
            
            if (!state.p5Instance) {
                state.p5Instance = new p5(sketch);
            } else {
                state.p5Instance.resizeCanvas(
                    dom.canvasContainer.offsetWidth, 
                    dom.canvasContainer.offsetHeight
                );
                showNextProblem();
            }
        }

        function showNextProblem(p5_instance_from_setup) {
            if (state.currentIndex >= state.totalQuestions || state.lives <= 0) {
                if (state.p5Instance || p5_instance_from_setup) endGame();
                return;
            }
            
            resetState();
            updateHUD();
            const problem = state.shuffledProblems[state.currentIndex];
            
            const p5_to_use = p5_instance_from_setup || state.p5Instance;
            p5_to_use.updateWithNewProblem(problem);
            generateAnswers(problem.answer);
        }
        
        function selectAnswer(e) {
            const selectedBtn = e.target;
            const isCorrect = selectedBtn.dataset.correct === 'true';
            
            // Deshabilitar todos los botones
            Array.from(dom.answerButtons.children).forEach(button => {
                button.disabled = true;
                if (button.dataset.correct === 'true') {
                    button.classList.add('correct');
                }
            });
            
            if (!isCorrect) {
                selectedBtn.classList.add('incorrect');
                state.lives--;
            } else {
                state.score += getDifficultyPoints();
                state.correctCount++;
            }
            
            updateHUD();
            showFeedback(isCorrect);
            
            // Continuar al siguiente problema
            setTimeout(() => {
                dom.modal.classList.remove('show');
                state.currentIndex++;
                showNextProblem();
            }, 3500);
        }

        function getDifficultyPoints() {
            switch (state.difficulty) {
                case 'normal': return 10;
                case 'hard': return 15;
                case 'expert': return 25;
                default: return 10;
            }
        }

        function endGame() {
            switchScreen(dom.endScreen);
            
            const totalTime = Math.round((Date.now() - state.startTime) / 1000);
            const accuracy = ((state.correctCount / state.totalQuestions) * 100).toFixed(1);
            const grade = ((state.correctCount / state.totalQuestions) * 5).toFixed(1);
            
            // Títulos según rendimiento
            let title = '¡Sigue Practicando!';
            if (grade >= 4.5) title = '🏆 ¡Maestro Absoluto de Thales!';
            else if (grade >= 4.0) title = '🌟 ¡Experto en Proporciones!';
            else if (grade >= 3.5) title = '⭐ ¡Muy Buen Trabajo!';
            else if (grade >= 3.0) title = '👍 ¡Buen Progreso!';
            
            document.getElementById('end-title').innerText = title;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('correct-answers').innerText = state.correctCount;
            document.getElementById('incorrect-answers').innerText = state.totalQuestions - state.correctCount;
            document.getElementById('accuracy').innerText = accuracy + '%';
            document.getElementById('final-grade').innerText = grade + '/5.0';
            document.getElementById('total-time').innerText = formatTime(totalTime);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // ============================================
        // FUNCIONES AUXILIARES
        // ============================================
        function updateHUD() {
            dom.score.innerText = `🎯 ${state.score}`;
            dom.lives.innerHTML = '❤️'.repeat(Math.max(0, state.lives));
            dom.questionCounter.innerText = `${state.currentIndex + 1}/${state.totalQuestions}`;
        }

        function resetState() {
            dom.answerButtons.innerHTML = '';
        }

        function generateAnswers(correctAnswer) {
            let answers = [correctAnswer];
            const isDecimal = correctAnswer % 1 !== 0;
            
            // Generar respuestas incorrectas más inteligentes
            while (answers.length < 4) {
                let wrongAnswer;
                const variation = Math.random() * 6 + 1;
                
                if (isDecimal) {
                    if (Math.random() > 0.5) {
                        wrongAnswer = Math.round((correctAnswer + variation) * 10) / 10;
                    } else {
                        wrongAnswer = Math.round(Math.max(0.1, correctAnswer - variation) * 10) / 10;
                    }
                } else {
                    if (Math.random() > 0.5) {
                        wrongAnswer = Math.round(correctAnswer + variation);
                    } else {
                        wrongAnswer = Math.max(1, Math.round(correctAnswer - variation));
                    }
                }
                
                if (!answers.includes(wrongAnswer) && wrongAnswer > 0) {
                    answers.push(wrongAnswer);
                }
            }
            
            // Mezclar respuestas
            answers.sort(() => Math.random() - 0.5);

            // Crear botones con mejor accesibilidad
            answers.forEach(answer => {
                const button = document.createElement('button');
                button.innerText = answer;
                button.classList.add('btn');
                button.setAttribute('aria-label', `Respuesta: ${answer}`);
                if (answer === correctAnswer) {
                    button.dataset.correct = true;
                }
                button.addEventListener('click', selectAnswer);
                dom.answerButtons.appendChild(button);
            });
        }
        
        function showFeedback(isCorrect) {
            const problem = state.shuffledProblems[state.currentIndex];
            
            dom.modalHeader.style.color = isCorrect ? 'var(--success)' : 'var(--error)';
            dom.modalHeader.innerText = isCorrect ? '🎉 ¡Excelente!' : '❌ Incorrecto';
            
            const feedbackHTML = `
                <div style="margin: 20px 0;">
                    <p style="font-size: clamp(1rem, 2.5vw, 1.3rem); margin-bottom: 15px;">
                        <strong>Respuesta correcta:</strong> ${problem.answer}
                    </p>
                    <p style="font-size: clamp(0.9rem, 2.5vw, 1.1rem);"><strong>Explicación paso a paso:</strong></p>
                    <div style="margin-top: 15px; font-size: clamp(0.8rem, 2vw, 1rem); line-height: 1.6;">${problem.explanation}</div>
                </div>
            `;
            
            dom.modalFeedbackText.innerHTML = feedbackHTML;
            
            // Renderizar MathJax con manejo de errores mejorado
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([dom.modalFeedbackText])
                    .then(() => {
                        console.log('MathJax renderizado correctamente');
                    })
                    .catch((err) => {
                        console.warn('Error al renderizar MathJax:', err);
                    });
            }
            
            dom.modal.classList.add('show');
        }
        
        function switchScreen(screenToShow) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            screenToShow.classList.add('active');
            
            // Ajustar canvas si es necesario
            if (screenToShow === dom.gameScreen && state.p5Instance) {
                setTimeout(() => {
                    state.p5Instance.resizeCanvas(
                        dom.canvasContainer.offsetWidth, 
                        dom.canvasContainer.offsetHeight
                    );
                    state.p5Instance.redraw();
                }, 100);
            }
        }

        // ============================================
        // INICIALIZACIÓN Y MEJORAS DE RENDIMIENTO
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            // Inicializar el juego
            initGame();
            
            // Mejorar rendimiento en dispositivos móviles
            if ('ontouchstart' in window) {
                document.body.classList.add('touch-device');
                
                // Prevenir zoom accidental en iOS
                document.addEventListener('touchstart', function(e) {
                    if (e.touches.length > 1) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Optimizar eventos táctiles
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(e) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }
            
            // Precargar recursos si es necesario
            preloadResources();
        });

        function preloadResources() {
            // Precargar fuentes si es necesario
            const fontPreload = document.createElement('link');
            fontPreload.rel = 'preload';
            fontPreload.as = 'font';
            fontPreload.type = 'font/woff2';
            fontPreload.crossOrigin = 'anonymous';
            document.head.appendChild(fontPreload);
        }

        // Manejo de errores global
        window.addEventListener('error', function(e) {
            console.error('Error en el juego:', e.error);
            // Aquí podrías enviar el error a un servicio de monitoreo
        });

        // Optimización para dispositivos de baja potencia
        const isLowPowerDevice = () => {
            return navigator.hardwareConcurrency <= 2 || 
                   /Android.*SM-/.test(navigator.userAgent) ||
                   window.screen.width <= 480;
        };

        if (isLowPowerDevice()) {
            document.documentElement.style.setProperty('--animation-duration', '0.2s');
            console.log('Optimizaciones para dispositivo de baja potencia aplicadas');
        }
    </script>
</body>
</html>